defmodule RealProductSizeBackend.AiCrawler.GeminiService do
  @moduledoc """
  Gemini AI service for product data extraction.

  Handles communication with Google's Gemini API for extracting
  product information from HTML content.
  """

  require Logger

  @gemini_api_url "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent"
  @max_retries 3
  @retry_delay 1000

  @doc """
  Extracts product data using Gemini AI.

  ## Examples

      iex> GeminiService.extract_product_data("Extract product info from: <html>...</html>")
      {:ok, %{title: "Product Title", price: "1234", ...}}

      iex> GeminiService.extract_product_data("invalid_prompt")
      {:error, "Gemini API request failed"}
  """
  def extract_product_data(prompt) do
    RealProductSizeBackend.CircuitBreaker.call_with_circuit_breaker(
      :gemini_api,
      fn -> do_gemini_extraction(prompt) end,
      fn -> {:error, :service_unavailable} end
    )
  end

  defp do_gemini_extraction(prompt) do
    api_key = Application.get_env(:real_product_size_backend, :gemini_api_key)

    if is_nil(api_key) or api_key == "" do
      {:error, "Gemini API key not configured"}
    else
      make_gemini_request(prompt, api_key, @max_retries)
    end
  end

  defp make_gemini_request(prompt, api_key, retries_left) do
    request_body = build_gemini_request_body(prompt)

    # Gemini uses API key as query parameter, not Bearer token
    url_with_key = "#{@gemini_api_url}?key=#{api_key}"

    debug_info = %{
      raw_request: %{
        url: url_with_key,
        body: request_body
      },
      model: "gemini-2.0-flash",
      provider: "gemini"
    }

    case Req.post(url_with_key,
           json: request_body,
           receive_timeout: 30_000
         ) do
      {:ok, response} when response.status == 200 ->
        parse_gemini_response(response.body)

      {:ok, response} when response.status == 429 ->
        # Rate limit - retry with backoff
        if retries_left > 0 do
          Logger.warning("Gemini API rate limited, retrying in #{@retry_delay}ms")
          :timer.sleep(@retry_delay)
          make_gemini_request(prompt, api_key, retries_left - 1)
        else
          {:error, {"Gemini API rate limit exceeded", debug_info}}
        end

      {:ok, response} ->
        Logger.error("Gemini API error: #{response.status} - #{inspect(response.body)}")
        {:error, {"Gemini API request failed with status: #{response.status}", debug_info}}

      {:error, reason} ->
        Logger.error("Gemini API request failed: #{inspect(reason)}")
        {:error, {"Gemini API request failed: #{inspect(reason)}", debug_info}}
    end
  end

  defp build_gemini_request_body(prompt) do
    %{
      contents: [
        %{
          parts: [
            %{
              text: prompt
            }
          ]
        }
      ],
      generationConfig: %{
        temperature: 0.1,
        topK: 1,
        topP: 0.8,
        maxOutputTokens: 2048,
        stopSequences: []
      },
      safetySettings: [
        %{
          category: "HARM_CATEGORY_HARASSMENT",
          threshold: "BLOCK_MEDIUM_AND_ABOVE"
        },
        %{
          category: "HARM_CATEGORY_HATE_SPEECH",
          threshold: "BLOCK_MEDIUM_AND_ABOVE"
        },
        %{
          category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
          threshold: "BLOCK_MEDIUM_AND_ABOVE"
        },
        %{
          category: "HARM_CATEGORY_DANGEROUS_CONTENT",
          threshold: "BLOCK_MEDIUM_AND_ABOVE"
        }
      ]
    }
  end

  defp parse_gemini_response(response_body) do
    debug_info = %{
      raw_response: response_body,
      model: "gemini-2.0-flash",
      provider: "gemini"
    }

    case response_body do
      %{"candidates" => [%{"content" => %{"parts" => [%{"text" => text}]}}]} ->
        {:ok, {text, debug_info}}

      %{"candidates" => []} ->
        {:error, {"No content generated by Gemini", debug_info}}

      %{"error" => %{"message" => message}} ->
        {:error, {"Gemini API error: #{message}", debug_info}}

      response ->
        Logger.warning("Unexpected Gemini response format: #{inspect(response)}")
        {:error, {"Unexpected response format from Gemini API", debug_info}}
    end
  end

  @doc """
  Test Gemini API connectivity.
  """
  def test_connection do
    test_prompt =
      "Extract product information from this simple HTML: <html><body><h1>Test Product</h1><span class='price'>$19.99</span></body></html>"

    case extract_product_data(test_prompt) do
      {:ok, response} ->
        Logger.info("Gemini API test successful: #{String.slice(response, 0, 100)}...")
        {:ok, response}

      {:error, reason} ->
        Logger.error("Gemini API test failed: #{reason}")
        {:error, reason}
    end
  end

  @doc """
  Get Gemini API usage statistics.
  """
  def get_usage_stats do
    # This would typically track token usage, but for now return basic info
    %{
      provider: "gemini",
      model: "gemini-2.0-flash",
      api_url: @gemini_api_url,
      max_retries: @max_retries
    }
  end
end
