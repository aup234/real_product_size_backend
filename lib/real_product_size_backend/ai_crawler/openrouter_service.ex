defmodule RealProductSizeBackend.AiCrawler.OpenRouterService do
  @moduledoc """
  OpenRouter AI service for product data extraction.

  Handles communication with OpenRouter API for extracting
  product information from HTML content using various models.
  """

  require Logger

  @openrouter_api_url "https://openrouter.ai/api/v1/chat/completions"
  @max_retries 3
  @retry_delay 1000

  @doc """
  Extracts product data using OpenRouter AI.

  ## Examples

      iex> OpenRouterService.extract_product_data("Extract product info from: <html>...</html>")
      {:ok, %{title: "Product Title", price: "1234", ...}}

      iex> OpenRouterService.extract_product_data("invalid_prompt")
      {:error, "OpenRouter API request failed"}
  """
  def extract_product_data(prompt) do
    RealProductSizeBackend.CircuitBreaker.call_with_circuit_breaker(
      :openrouter_api,
      fn -> do_openrouter_extraction(prompt) end,
      fn -> {:error, :service_unavailable} end
    )
  end

  defp do_openrouter_extraction(prompt) do
    api_key = Application.get_env(:real_product_size_backend, :openrouter_api_key)

    if is_nil(api_key) or api_key == "" do
      {:error, "OpenRouter API key not configured"}
    else
      make_openrouter_request(prompt, api_key, @max_retries)
    end
  end

  defp make_openrouter_request(prompt, api_key, retries_left) do
    request_body = build_openrouter_request_body(prompt)

    headers = [
      {"Authorization", "Bearer #{api_key}"},
      {"Content-Type", "application/json"},
      {"HTTP-Referer", Application.get_env(:real_product_size_backend, :openrouter_referer, "http://localhost:6800")},
      {"X-Title", Application.get_env(:real_product_size_backend, :openrouter_title, "Real Product Size Backend")}
    ]

    debug_info = %{
      raw_request: %{
        url: @openrouter_api_url,
        headers: headers,
        body: request_body
      },
      model: request_body.model,
      provider: "openrouter"
    }

    case Req.post(@openrouter_api_url,
           headers: headers,
           json: request_body,
           receive_timeout: 30_000
         ) do
      {:ok, response} when response.status == 200 ->
        parse_openrouter_response(response.body)

      {:ok, response} when response.status == 429 ->
        # Rate limit - retry with backoff
        if retries_left > 0 do
          Logger.warning("OpenRouter API rate limited, retrying in #{@retry_delay}ms")
          :timer.sleep(@retry_delay)
          make_openrouter_request(prompt, api_key, retries_left - 1)
        else
          {:error, {"OpenRouter API rate limit exceeded", debug_info}}
        end

      {:ok, response} ->
        Logger.error("OpenRouter API error: #{response.status} - #{inspect(response.body)}")
        {:error, {"OpenRouter API request failed with status: #{response.status}", debug_info}}

      {:error, reason} ->
        Logger.error("OpenRouter API request failed: #{inspect(reason)}")
        {:error, {"OpenRouter API request failed: #{inspect(reason)}", debug_info}}
    end
  end

  defp build_openrouter_request_body(prompt) do
    %{
      model: "meta-llama/llama-3.3-70b-instruct:free",
      messages: [
        %{
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.1,
      max_tokens: 2048,
      top_p: 0.8,
      frequency_penalty: 0.0,
      presence_penalty: 0.0,
      stop: nil
    }
  end

  defp parse_openrouter_response(response_body) do
    debug_info = %{
      raw_response: response_body,
      model: "google/gemma-3n-e4b-it:free",
      provider: "openrouter"
    }

    case response_body do
      %{"choices" => [%{"message" => %{"content" => content}}]} ->
        {:ok, {content, debug_info}}

      %{"choices" => []} ->
        {:error, {"No content generated by OpenRouter", debug_info}}

      %{"error" => %{"message" => message}} ->
        {:error, {"OpenRouter API error: #{message}", debug_info}}

      response ->
        Logger.warning("Unexpected OpenRouter response format: #{inspect(response)}")
        {:error, {"Unexpected response format from OpenRouter API", debug_info}}
    end
  end

  @doc """
  Test OpenRouter API connectivity.
  """
  def test_connection do
    test_prompt =
      "Extract product information from this simple HTML: <html><body><h1>Test Product</h1><span class='price'>$19.99</span></body></html>"

    case extract_product_data(test_prompt) do
      {:ok, response} ->
        Logger.info("OpenRouter API test successful: #{String.slice(response, 0, 100)}...")
        {:ok, response}

      {:error, reason} ->
        Logger.error("OpenRouter API test failed: #{reason}")
        {:error, reason}
    end
  end

  @doc """
  Get OpenRouter API usage statistics.
  """
  def get_usage_stats do
    # This would typically track token usage, but for now return basic info
    %{
      provider: "openrouter",
      model: "openai/gpt-4o",
      api_url: @openrouter_api_url,
      max_retries: @max_retries
    }
  end

  @doc """
  Estimate token usage for cost calculation.
  """
  def estimate_token_usage(prompt) do
    # Rough estimation: 1 token â‰ˆ 4 characters for English text
    # This is a simplified estimation for cost planning
    estimated_tokens = byte_size(prompt) / 4

    %{
      input_tokens: round(estimated_tokens),
      # Estimated output tokens
      output_tokens: 500,
      total_tokens: round(estimated_tokens + 500)
    }
  end

  @doc """
  Calculate estimated cost for OpenRouter API usage.
  """
  def calculate_estimated_cost(prompt) do
    usage = estimate_token_usage(prompt)

    # OpenRouter pricing varies by model. Using GPT-4o as example:
    # $2.50 per million input tokens, $10.00 per million output tokens (approximate)
    input_cost = usage.input_tokens / 1_000_000 * 2.50
    output_cost = usage.output_tokens / 1_000_000 * 10.00
    total_cost = input_cost + output_cost

    %{
      input_cost: input_cost,
      output_cost: output_cost,
      total_cost: total_cost,
      usage: usage
    }
  end
end
